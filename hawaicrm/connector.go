package hawaicrm

import (
	"crypto/md5"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
)

var (
	Addr      string
	SessionId string
	Client    *http.Client
)

// Transfer type for SuiteCRM requests
// A map doesn't work here because order seems to be important
type RestData struct {
	Session       string         `json:"session"`
	ModuleName    string         `json:"module_name"`
	NameValueList []KeyValuePair `json:"name_value_list"`
}

type KeyValuePair struct {
	Key   string `json:"name"`
	Value string `json:"value"`
}

// Transfer type for SuiteCRM authentication data
type AuthData struct {
	UserName string `json:"user_name"`
	Password string `json:"password"`
}

type LoginData struct {
	AuthData AuthData `json:"user_auth"`
	AppName  string   `json:"application_name"`
}

// Create a connection to SuiteCRM
func Connect(addr string, user string, pwd string) error {
	Addr = addr

	// Set up login data
	h := md5.New()
	io.WriteString(h, pwd)
	pwdHashStr := fmt.Sprintf("%x", h.Sum(nil))
	restDataBytes, err := json.Marshal(LoginData{
		AppName: "SuiteCRM Adapter",
		AuthData: AuthData{
			UserName: user,
			Password: pwdHashStr,
		},
	})
	if err != nil {
		log.Fatalf("illegal credential format: %s", err)
	}
	restData := string(restDataBytes[:])

	// Set up connection request
	Url, err := url.Parse(addr)
	if err != nil {
		log.Fatalf("Illegal URL: %s", err)
	}
	Url.Scheme = "http"
	q := Url.Query()
	q.Set("method", "login")
	q.Set("input_type", "json")
	q.Set("response_type", "json")
	q.Set("rest_data", restData)
	Url.RawQuery = q.Encode()

	// Connect to SuiteCRM instance
	tr := &http.Transport{}
	Client = &http.Client{Transport: tr}
	resp, err := Client.Get(Url.String())
	if err != nil {
		err = errors.New("Can't connect to SuiteCRM: " + err.Error())
		return err
	}
	defer resp.Body.Close()
	log.Printf("Connection Query: %s", Url.String())

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		err = errors.New("Can't read response by SuiteCRM: " + err.Error())
		return err
	}

	var data map[string]interface{}
	err = json.Unmarshal(body, &data)
	if err != nil {
		err = errors.New("Can't read response by SuiteCRM: " + err.Error())
		return err
	}

	sid, ok := data["id"].(string)
	if !ok {
		err = errors.New("Can't read session id: " + err.Error())
		return err
	}
	SessionId = sid
	log.Printf("Connection established. ID %s", SessionId)
	return nil
}

func SetEntry(module string, nameValueList []KeyValuePair) (interface{}, error) {
	return send(module, "set_entry", nameValueList)
}

func GetEntry(module string, nameValueList []KeyValuePair) (interface{}, error) {
	return send(module, "get_entry", nameValueList)
}

func send(module string, method string, valueList []KeyValuePair) (interface{}, error) {
	if Client == nil {
		err := errors.New("Connection not available: HTTP Client is nil")
		return nil, err
	}

	//myNameValueList := []KeyValuePair{
	//	KeyValuePair{"name", "GENERATED BY Proxy"},
	//	KeyValuePair{"status", "Unpaid"},
	//}

	r := RestData{SessionId, module, valueList}
	restDataJson, err := json.Marshal(r)
	if err != nil {
		err := errors.New("illegal JSON format: " + err.Error())
		return nil, err
	}
	restDataJsonString := string(restDataJson[:])
	log.Printf("restDataJsonString: %s", restDataJsonString)

	Url, err := url.Parse(Addr)
	if err != nil {
		log.Fatalf("Illegal URL: %s", err)
	}

	Url.Scheme = "http"

	// Assemble query string
	q := Url.Query()
	q.Set("method", method)
	q.Set("input_type", "json")
	q.Set("response_type", "json")
	q.Set("rest_data", restDataJsonString)
	Url.RawQuery = q.Encode()

	// Create and send request
	req, err := http.NewRequest("POST", Url.String(), nil)
	if err != nil {
		return nil, err
	}

	resp, err := Client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Handle response
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var responseMap map[string]interface{}
	err = json.Unmarshal(body, &responseMap)
	if err != nil {
		return nil, err
	}

	log.Printf("Sent: %s", Url.String())
	log.Printf("Received: %s", body)
	return string(body[:]), nil
}
